/**
 * Planner Tools - Multi-model plan creation and execution
 *
 * planner_maker: Council-based plan synthesis with smart search
 *   - Phase 0: ASK RIGHT QUESTIONS (first principles, problem decomposition, UX)
 *   - Phase 1: Data gathering (grok + openai/gemini search)
 *   - Phase 2: Analysis (qwen, minimax, kimi)
 *   - Phase 3: Critique (gpt finds holes)
 *   - Phase 4: Judgment (qwen_reason â†’ gemini final)
 *
 * planner_runner: Execute plans with verification checkpoints
 */

import { z } from "zod";
import { withHeartbeat } from "../utils/streaming-helper.js";

// Match MCPContext from server.ts
type MCPContext = {
  log: {
    info: (message: string, metadata?: Record<string, any>) => void;
    error: (message: string, metadata?: Record<string, any>) => void;
    warn: (message: string, metadata?: Record<string, any>) => void;
    debug: (message: string, metadata?: Record<string, any>) => void;
  };
  reportProgress?: (progress: { progress: number; total: number }) => Promise<void>;
  [key: string]: any;
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DEVLOG INTEGRATION TYPES
// Structured hints for devlog-mcp sync (hybrid approach)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Structured hint for devlog tool invocation
 * Claude can validate/modify before executing
 */
export interface DevlogHint {
  tool: "devlog_session_log" | "devlog_plan_create" | "devlog_plan_check" | "devlog_plan_blocker" | "devlog_plan_validate";
  params: Record<string, any>;
  description?: string;  // Human-readable explanation
}

/**
 * Plan step with devlog mapping
 */
export interface PlanStep {
  index: number;
  description: string;
  complexity?: string;  // O notation
  checkpoint?: "50%" | "100%";
}

/**
 * Extract numbered steps from plan text
 * Parses formats like "1. Do X" or "Step 1: Do X"
 */
function extractPlanSteps(planText: string): PlanStep[] {
  const steps: PlanStep[] = [];
  // Match numbered items: "1. text" or "Step 1: text" or "- [ ] text"
  const stepPatterns = [
    /^\s*(\d+)\.\s+(.+)$/gm,           // "1. text"
    /^\s*Step\s+(\d+)[:\s]+(.+)$/gim,  // "Step 1: text"
    /^\s*-\s*\[\s*\]\s+(.+)$/gm,       // "- [ ] text" (checklist)
  ];

  let match;
  let index = 1;

  // Try numbered patterns first
  for (const pattern of stepPatterns.slice(0, 2)) {
    pattern.lastIndex = 0;
    while ((match = pattern.exec(planText)) !== null) {
      const stepNum = parseInt(match[1], 10);
      const desc = match[2].trim();
      // Extract O() notation if present
      const complexityMatch = desc.match(/O\([^)]+\)/i);
      steps.push({
        index: stepNum,
        description: desc.substring(0, 200),  // Truncate long descriptions
        complexity: complexityMatch?.[0],
      });
    }
    if (steps.length > 0) break;
  }

  // Fallback to checklist format
  if (steps.length === 0) {
    const checklistPattern = stepPatterns[2];
    checklistPattern.lastIndex = 0;
    while ((match = checklistPattern.exec(planText)) !== null) {
      steps.push({
        index: index++,
        description: match[1].trim().substring(0, 200),
      });
    }
  }

  // Assign checkpoints (50% and 100%)
  if (steps.length > 0) {
    const midpoint = Math.floor(steps.length / 2);
    if (midpoint > 0 && steps[midpoint - 1]) {
      steps[midpoint - 1].checkpoint = "50%";
    }
    steps[steps.length - 1].checkpoint = "100%";
  }

  return steps;
}

/**
 * Generate devlog_plan_create hint from plan steps
 */
function generatePlanCreateHint(task: string, steps: PlanStep[]): DevlogHint {
  return {
    tool: "devlog_plan_create",
    params: {
      title: `Plan: ${task.substring(0, 100)}`,
      items: steps.map(s => s.description),
      description: `Generated by planner_maker at ${new Date().toISOString()}`,
    },
    description: `Create devlog plan with ${steps.length} items`,
  };
}

// Available prompt techniques for question generation
// Maps to techniques in prompt-technique-tools.ts
const QUESTION_TECHNIQUES = {
  first_principles: "first_prin",    // WHY - fundamental truths, challenge assumptions
  problem_decomposition: "decompose", // WHAT - break into sub-problems
  comprehensive_investigation: "investigate", // WHO/WHAT/WHEN/WHERE/WHY/HOW
  feasibility_analysis: "feasible",   // HOW - technical, economic, time
  alternative_perspectives: "alt_view", // Multiple viewpoints
} as const;

/**
 * PLANNER_MAKER
 *
 * Phase 0: ASK RIGHT QUESTIONS (Gemini selects techniques)
 *   - first_principles: WHY questions
 *   - problem_decomposition: WHAT questions
 *   - feasibility_analysis: HOW questions
 *   - Returns questions to user if no answers provided
 *
 * Phase 1: Data Gathering (Smart Search)
 * Phase 2: Analysis (parallel)
 * Phase 3: Critique (GPT finds holes)
 * Phase 4: Judgment (qwen_reason â†’ gemini final)
 */
export const plannerMakerTool = {
  name: "planner_maker",
  description: `Multi-model council for creating implementation plans.
FIRST asks clarifying questions using first-principles and UX thinking.
Then uses smart search, parallel analysis, GPT critique, and dual-judge synthesis.

Put your TASK in 'task'. If you have answers to previous questions, put them in 'answers'.`,
  parameters: z.object({
    task: z.string().describe("The task/goal to create a plan for (REQUIRED)"),
    context: z.string().optional().describe("Additional context, constraints, or requirements"),
    answers: z.string().optional().describe("Answers to previously asked questions (skip question phase if provided)"),
    searchDepth: z.enum(["quick", "standard", "deep"]).optional().default("standard")
      .describe("Search depth: quick (grok only), standard (grok + 1), deep (all search tools)"),
    skipQuestions: z.boolean().optional().default(false)
      .describe("Skip the question-asking phase"),
  }),
  execute: async (args: {
    task: string;
    context?: string;
    answers?: string;
    searchDepth?: "quick" | "standard" | "deep";
    skipQuestions?: boolean;
  }, ctx: MCPContext) => {
    const results: Record<string, string> = {};
    const log = (msg: string) => ctx.log.info(msg);
    const reportFn = ctx.reportProgress
      ? async () => { await ctx.reportProgress!({ progress: 0, total: 100 }); }
      : async () => {};

    // Dynamic imports
    const { grokSearchTool } = await import("./grok-enhanced.js");
    const { geminiAnalyzeTextTool, geminiSearchTool } = await import("./gemini-tools.js");
    const { openaiSearchTool, openaiGpt5ReasonTool } = await import("./openai-tools.js");
    const { qwenCoderTool, kimiThinkingTool, qwenReasonTool, minimaxCodeTool } = await import("./openrouter-tools.js");
    const { executePromptTechniqueTool } = await import("./prompt-technique-tools.js");

    const mockCtx: MCPContext = {
      log: { info: () => {}, error: () => {}, warn: () => {}, debug: () => {} },
      reportProgress: async () => {}
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PHASE 0: ASK RIGHT QUESTIONS (First Principles + UX Thinking)
    // Uses execute_prompt_technique for consistent prompt engineering
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if (!args.skipQuestions && !args.answers) {
      log("ğŸ¤” Phase 0: Generating RIGHT questions using prompt techniques...");

      // Step 1: Gemini decides which techniques to use
      const techniqueSelectionPrompt = `You are selecting prompt engineering techniques to ask the RIGHT questions before planning.

TASK: ${args.task}
${args.context ? `CONTEXT: ${args.context}` : ""}

Available techniques (use the short alias):
1. first_prin - Ask WHY questions, challenge assumptions, find fundamental truths
2. decompose - Ask WHAT questions, break into sub-problems, identify dependencies
3. investigate - Ask WHO/WHAT/WHEN/WHERE/WHY/HOW questions (5W1H)
4. feasible - Ask HOW questions about technical/economic/time feasibility
5. alt_view - Ask questions from 5 different viewpoints

Select 2-3 MOST RELEVANT technique aliases for this task. Return ONLY the aliases, comma-separated.
Example: "first_prin, decompose"`;

      const techniqueSelection = await withHeartbeat(
        () => geminiAnalyzeTextTool.execute({
          text: techniqueSelectionPrompt,
          type: "general"
        }, mockCtx),
        reportFn
      );
      results.selected_techniques = String(techniqueSelection);

      // Step 2: Apply selected techniques using execute_prompt_technique
      const questionPrompts: string[] = [];

      // Parse selected techniques
      const validAliases = Object.values(QUESTION_TECHNIQUES);
      const selectedAliases = String(techniqueSelection)
        .toLowerCase()
        .replace(/[^a-z_,\s]/g, '')
        .split(/[,\s]+/)
        .filter(t => validAliases.includes(t as any));

      // Fallback if parsing fails
      const techniquesToUse = selectedAliases.length > 0
        ? selectedAliases
        : ["first_prin", "decompose"];

      for (const technique of techniquesToUse) {
        // Use the prompt technique tool to get enhanced prompts
        const enhancedResult = await withHeartbeat(
          () => executePromptTechniqueTool.execute({
            technique: technique,
            tool: "gemini_analyze_text",  // Use Gemini for technique execution
            query: args.task
          }, mockCtx),
          reportFn
        );
        questionPrompts.push(`### ${technique.toUpperCase()}\n${String(enhancedResult).substring(0, 1500)}`);
      }

      // Step 3: Qwen synthesizes into clear, user-facing questions
      const questionSynthesisPrompt = `Based on these technique-enhanced analyses, generate 5-7 SPECIFIC questions to ask the user BEFORE creating an implementation plan.

TASK: ${args.task}

TECHNIQUE OUTPUTS:
${questionPrompts.join('\n\n')}

Generate questions that:
1. Challenge assumptions (WHY is this needed? WHY this approach?)
2. Clarify scope (WHAT exactly? WHAT's out of scope?)
3. Identify constraints (WHAT limits? WHAT resources?)
4. Understand users (WHO will use this? WHO maintains it?)
5. Define success (HOW will we know it works?)

Format as numbered list. Be SPECIFIC to this task, not generic.
Each question should reveal something that would change the implementation.`;

      const synthesizedQuestions = await withHeartbeat(
        () => qwenReasonTool.execute({
          problem: questionSynthesisPrompt,
          approach: "logical",
        }, mockCtx),
        reportFn
      );

      // Return questions to user
      return `# ğŸ¤” Before I Create Your Plan...

## Task Understanding
${args.task}

## Techniques Applied
${techniquesToUse.join(', ')}

## Questions to Consider

${synthesizedQuestions}

---

**To continue:** Call \`planner_maker\` again with your \`answers\` to these questions.

Example:
\`\`\`
planner_maker({
  task: "${args.task}",
  answers: "1. [your answer]\\n2. [your answer]\\n..."
})
\`\`\`
`;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PHASE 1: Data Gathering (Smart Search)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    log("ğŸ“¡ Phase 1: Data Gathering...");

    // Include answers in search context
    const searchContext = args.answers
      ? `${args.task}\n\nUser clarifications:\n${args.answers}`
      : args.task;

    // Grok always searches
    const grokResult = await withHeartbeat(
      () => grokSearchTool.execute({ query: searchContext, maxResults: 5 }, mockCtx),
      reportFn
    );
    results.grok_search = String(grokResult);

    if (args.searchDepth !== "quick") {
      // Standard: add one more search
      const secondarySearch = Math.random() > 0.5 ? "openai" : "gemini";

      if (secondarySearch === "openai") {
        const openaiResult = await withHeartbeat(
          () => openaiSearchTool.execute({ query: searchContext }, mockCtx),
          reportFn
        );
        results.openai_search = String(openaiResult);
      } else {
        const geminiResult = await withHeartbeat(
          () => geminiSearchTool.execute({ query: searchContext }, mockCtx),
          reportFn
        );
        results.gemini_search = String(geminiResult);
      }

      // Deep: use all + check for discrepancies
      if (args.searchDepth === "deep") {
        if (!results.openai_search) {
          const r = await withHeartbeat(
            () => openaiSearchTool.execute({ query: searchContext }, mockCtx),
            reportFn
          );
          results.openai_search = String(r);
        }
        if (!results.gemini_search) {
          const r = await withHeartbeat(
            () => geminiSearchTool.execute({ query: searchContext }, mockCtx),
            reportFn
          );
          results.gemini_search = String(r);
        }

        // Check for discrepancies
        const discrepancyCheck = await withHeartbeat(
          () => geminiAnalyzeTextTool.execute({
            text: `Compare these search results for discrepancies:

GROK: ${results.grok_search?.substring(0, 1500)}
OPENAI: ${results.openai_search?.substring(0, 1500)}
GEMINI: ${results.gemini_search?.substring(0, 1500)}

Are there significant discrepancies? Which source is most reliable?`,
            type: "general"
          }, mockCtx),
          reportFn
        );
        results.search_reconciliation = String(discrepancyCheck);
      }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PHASE 2: Analysis (parallel conceptually)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    log("ğŸ”¬ Phase 2: Analysis...");

    const analysisPrompt = `Task: ${args.task}
${args.context ? `Context: ${args.context}` : ""}
${args.answers ? `User Clarifications:\n${args.answers}` : ""}
${results.grok_search ? `Research: ${results.grok_search.substring(0, 2000)}` : ""}

Analyze feasibility and provide implementation approach.`;

    // Qwen Coder - code feasibility
    const qwenResult = await withHeartbeat(
      () => qwenCoderTool.execute({
        task: "analyze",
        requirements: analysisPrompt,
      }, mockCtx),
      reportFn
    );
    results.qwen_analysis = String(qwenResult);

    // MiniMax - implementation check
    const minimaxResult = await withHeartbeat(
      () => minimaxCodeTool.execute({
        task: "review",
        requirements: analysisPrompt,
      }, mockCtx),
      reportFn
    );
    results.minimax_analysis = String(minimaxResult);

    // Kimi - step-by-step reasoning
    const kimiResult = await withHeartbeat(
      () => kimiThinkingTool.execute({
        problem: analysisPrompt,
        approach: "systematic",
      }, mockCtx),
      reportFn
    );
    results.kimi_analysis = String(kimiResult);

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PHASE 3: Critique (GPT finds holes)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    log("ğŸ” Phase 3: Critique...");

    const critiquePrompt = `Review this plan for holes, gaps, and weaknesses:

TASK: ${args.task}
${args.answers ? `USER CLARIFICATIONS:\n${args.answers}` : ""}

QWEN ANALYSIS: ${results.qwen_analysis?.substring(0, 1500)}
MINIMAX ANALYSIS: ${results.minimax_analysis?.substring(0, 1500)}
KIMI ANALYSIS: ${results.kimi_analysis?.substring(0, 1500)}

Find:
1. Missing considerations
2. Potential failure points
3. Security concerns
4. Performance issues (especially anything > O(1))
5. Edge cases not covered`;

    const gptResult = await withHeartbeat(
      () => openaiGpt5ReasonTool.execute({
        query: critiquePrompt,
        mode: "analytical",
      }, mockCtx),
      reportFn
    );
    results.gpt_critique = String(gptResult);

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PHASE 4: Judgment (qwen_reason â†’ gemini final)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    log("âš–ï¸ Phase 4: Judgment...");

    const qwenJudgePrompt = `Synthesize a coherent implementation plan:

TASK: ${args.task}
${args.answers ? `USER REQUIREMENTS:\n${args.answers}` : ""}

ANALYSES:
- Qwen: ${results.qwen_analysis?.substring(0, 1000)}
- MiniMax: ${results.minimax_analysis?.substring(0, 1000)}
- Kimi: ${results.kimi_analysis?.substring(0, 1000)}

CRITIQUE (holes found):
${results.gpt_critique?.substring(0, 1000)}

Create a structured plan addressing all concerns.`;

    const qwenJudgeResult = await withHeartbeat(
      () => qwenReasonTool.execute({
        problem: qwenJudgePrompt,
        approach: "logical",
      }, mockCtx),
      reportFn
    );
    results.qwen_judgment = String(qwenJudgeResult);

    // Gemini - final judge
    const finalPrompt = `Create the FINAL implementation plan.

TASK: ${args.task}
${args.context ? `CONTEXT: ${args.context}` : ""}
${args.answers ? `USER REQUIREMENTS:\n${args.answers}` : ""}

QWEN'S DRAFT PLAN:
${results.qwen_judgment}

GPT'S CRITIQUE:
${results.gpt_critique?.substring(0, 800)}

Create a final, actionable plan with:
1. Clear numbered steps with success criteria
2. Complexity estimates (O notation)
3. Potential blockers and mitigations
4. Checkpoints at 50% and 100%`;

    const finalPlan = await withHeartbeat(
      () => geminiAnalyzeTextTool.execute({
        text: finalPrompt,
        type: "general"
      }, mockCtx),
      reportFn
    );

    return `# Implementation Plan

## Task
${args.task}

${args.answers ? `## User Requirements\n${args.answers}\n` : ""}

## Final Plan (Gemini Synthesis)
${finalPlan}

---

## Supporting Analysis

### Qwen Judgment
${results.qwen_judgment?.substring(0, 1500)}

### GPT Critique
${results.gpt_critique?.substring(0, 1000)}

### Search Summary
${results.search_reconciliation || results.grok_search?.substring(0, 500) || "No search performed"}

---

## Next Steps
Use \`planner_runner\` with this plan to track implementation:
- checkpoint: "start" - Begin implementation
- checkpoint: "50%" - Mid-point verification
- checkpoint: "100%" - Final review
`;
  }
};


/**
 * PLANNER_RUNNER
 *
 * Execution: minimax_agent + kimi (subagents)
 *
 * Continuous checks (qwen_algo + qwen_coder):
 *   - Following plan?
 *   - Security vulnerabilities?
 *   - Memory leaks?
 *   - Complexity > O(1)? Ask optimization question
 *
 * 50% Checkpoint: qwen_reason â†’ devlog
 * 100% Checkpoint: qwen_reason + qwen_coder (/10) + gemini â†’ devlog
 */
export const plannerRunnerTool = {
  name: "planner_runner",
  description: `Execute implementation plans with verification checkpoints.
Checks for security, memory leaks, and O(1) optimization opportunities.
Logs progress to devlog at 50% and 100%.`,
  parameters: z.object({
    plan: z.string().describe("The implementation plan to execute (from planner_maker)"),
    code: z.string().optional().describe("Current code state to verify against plan"),
    checkpoint: z.enum(["start", "50%", "100%"]).optional().default("start")
      .describe("Which checkpoint to run"),
    autoOptimize: z.boolean().optional().default(true)
      .describe("Ask about O(1) optimization opportunities"),
  }),
  execute: async (args: {
    plan: string;
    code?: string;
    checkpoint?: "start" | "50%" | "100%";
    autoOptimize?: boolean;
  }, ctx: MCPContext) => {
    const results: Record<string, string> = {};
    const log = (msg: string) => ctx.log.info(msg);
    const reportFn = ctx.reportProgress
      ? async () => { await ctx.reportProgress!({ progress: 0, total: 100 }); }
      : async () => {};

    // Dynamic imports
    const { geminiAnalyzeTextTool } = await import("./gemini-tools.js");
    const { qwenCoderTool, qwenAlgoTool, qwenReasonTool, minimaxAgentTool } = await import("./openrouter-tools.js");

    const mockCtx: MCPContext = {
      log: { info: () => {}, error: () => {}, warn: () => {}, debug: () => {} },
      reportProgress: async () => {}
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CONTINUOUS CHECKS (run at every checkpoint)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    log("ğŸ”„ Running continuous checks...");

    if (args.code) {
      // Check 1: Following plan?
      const alignmentResult = await withHeartbeat(
        () => minimaxAgentTool.execute({
          task: `Compare this code against the plan. Is it following the plan correctly?

PLAN:
${args.plan.substring(0, 2000)}

CODE:
${args.code!.substring(0, 3000)}

Answer: Following plan? Any deviations?`,
          outputFormat: "execute",
          steps: 3,
        }, mockCtx),
        reportFn
      );
      results.plan_alignment = String(alignmentResult);

      // Check 2: Security + Memory + Complexity
      const securityResult = await withHeartbeat(
        () => qwenCoderTool.execute({
          task: "analyze",
          code: args.code,
          requirements: `Analyze for:
1. SECURITY VULNERABILITIES (injection, XSS, auth issues)
2. MEMORY LEAKS (unclosed resources, circular refs, unbounded growth)
3. COMPLEXITY ANALYSIS (identify any O(n), O(nÂ²), etc. patterns)

For each O(n) or worse pattern found, ask: "Can this be optimized to O(1)?"`,
        }, mockCtx),
        reportFn
      );
      results.security_memory_check = String(securityResult);

      // Check 3: Algorithm optimization (qwen_algo)
      if (args.autoOptimize && args.code) {
        const codeToOptimize = args.code; // Capture for closure
        const algoResult = await withHeartbeat(
          () => qwenAlgoTool.execute({
            problem: codeToOptimize,
            focus: "optimize",
            context: "Find opportunities to optimize to O(1) where possible",
          }, mockCtx),
          reportFn
        );
        results.algo_optimization = String(algoResult);
      }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CHECKPOINT-SPECIFIC LOGIC
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    if (args.checkpoint === "50%") {
      log("ğŸ“ 50% Checkpoint: qwen_reason verification...");

      const midResult = await withHeartbeat(
        () => qwenReasonTool.execute({
          problem: `50% Progress Check:

PLAN: ${args.plan.substring(0, 1500)}

CURRENT STATE:
- Plan Alignment: ${results.plan_alignment?.substring(0, 500)}
- Security/Memory: ${results.security_memory_check?.substring(0, 500)}

Is the implementation on track? Any course corrections needed?`,
          approach: "logical",
        }, mockCtx),
        reportFn
      );
      results.midpoint_verification = String(midResult);

      // Devlog entry
      results.devlog_entry = `## 50% Checkpoint - ${new Date().toISOString()}
### Status: In Progress
### Plan Alignment: ${results.plan_alignment?.substring(0, 200)}
### Verification: ${results.midpoint_verification?.substring(0, 300)}`;
    }

    if (args.checkpoint === "100%") {
      log("ğŸ 100% Checkpoint: Final verification...");

      // qwen_reason check
      const finalQwenResult = await withHeartbeat(
        () => qwenReasonTool.execute({
          problem: `Final Verification:

PLAN: ${args.plan.substring(0, 1500)}

IMPLEMENTATION:
${args.code?.substring(0, 2000) || "No code provided"}

Is the plan fully implemented? Any gaps?`,
          approach: "logical",
        }, mockCtx),
        reportFn
      );
      results.final_qwen_check = String(finalQwenResult);

      // qwen_coder score (/10)
      const scoreResult = await withHeartbeat(
        () => qwenCoderTool.execute({
          task: "review",
          code: args.code || "// No code provided",
          requirements: `Score this implementation out of 10:
- Code quality
- Plan adherence
- Security
- Performance
- Maintainability

Give a score like "8/10" with brief justification.`,
        }, mockCtx),
        reportFn
      );
      results.qwen_score = String(scoreResult);

      // Gemini final judge
      const geminiResult = await withHeartbeat(
        () => geminiAnalyzeTextTool.execute({
          text: `Final Implementation Review:

PLAN: ${args.plan.substring(0, 1000)}

CODE: ${args.code?.substring(0, 1500) || "No code provided"}

QWEN SCORE: ${results.qwen_score?.substring(0, 500)}

SECURITY CHECK: ${results.security_memory_check?.substring(0, 500)}

Provide final verdict: APPROVED or NEEDS_REVISION with specific feedback.`,
          type: "general"
        }, mockCtx),
        reportFn
      );
      results.gemini_final = String(geminiResult);

      // Devlog entry
      results.devlog_entry = `## 100% Checkpoint - ${new Date().toISOString()}
### Status: Complete
### Qwen Score: ${results.qwen_score?.substring(0, 100)}
### Gemini Verdict: ${results.gemini_final?.substring(0, 200)}
### Security: ${results.security_memory_check?.substring(0, 200)}`;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // COMPILE RESULTS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const output = [`# Plan Runner - ${args.checkpoint} Checkpoint`];

    if (results.plan_alignment) {
      output.push(`\n## Plan Alignment\n${results.plan_alignment}`);
    }

    if (results.security_memory_check) {
      output.push(`\n## Security & Memory Analysis\n${results.security_memory_check}`);
    }

    if (results.algo_optimization) {
      output.push(`\n## O(1) Optimization Opportunities\n${results.algo_optimization}`);
    }

    if (args.checkpoint === "50%" && results.midpoint_verification) {
      output.push(`\n## 50% Verification\n${results.midpoint_verification}`);
    }

    if (args.checkpoint === "100%") {
      output.push(`\n## Final Scores`);
      output.push(`\n### Qwen Score\n${results.qwen_score}`);
      output.push(`\n### Gemini Verdict\n${results.gemini_final}`);
    }

    if (results.devlog_entry) {
      output.push(`\n---\n## Devlog Entry\n\`\`\`\n${results.devlog_entry}\n\`\`\``);
    }

    return output.join("\n");
  }
};

// Export all planner tools
export function getAllPlannerTools() {
  return [plannerMakerTool, plannerRunnerTool];
}
